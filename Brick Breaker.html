<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Brick Breaker - Touch Edition</title>
    <style>
        body { background: #020617; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #38bdf8; font-weight: bold; z-index: 10; }
        canvas { background: #000; border: 3px solid #1e293b; max-width: 95vw; max-height: 70vh; box-shadow: 0 0 30px rgba(56, 189, 248, 0.2); }
        .ui { position: absolute; top: 40px; text-align: center; pointer-events: none; }
        #score { font-size: 2rem; font-weight: bold; color: #38bdf8; }
    </style>
</head>
<body>

    <a href="index.html" class="back-link">‚Üê BACK TO ARCADE</a>
    
    <div class="ui">
        <div id="score">SCORE: 0</div>
        <div style="color: #64748b; font-size: 0.9rem;">Slide finger or move mouse to play</div>
    </div>

    <canvas id="brickCanvas" width="800" height="500"></canvas>

<script>
    const canvas = document.getElementById("brickCanvas");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score");

    let score = 0;
    let isGameOver = false;

    const paddle = { w: 120, h: 15, x: 340, y: 460 };
    // CONSTANT SPEED: Fixed at 5 to prevent lag and tunneling
    const ball = { x: 400, y: 440, r: 8, vx: 5, vy: -5 };
    
    let bricks = [];
    const rows = 5, cols = 8;
    const bW = 85, bH = 25, bPadding = 10;

    function initBricks() {
        bricks = [];
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                bricks.push({ 
                    x: c * (bW + bPadding) + 25, 
                    y: r * (bH + bPadding) + 60, 
                    active: true,
                    color: `hsl(${r * 40}, 70%, 50%)`
                });
            }
        }
    }

    // --- INPUT HANDLING (MOUSE & TOUCH) ---
    function handleInput(clientX) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        paddle.x = (clientX - rect.left) * scaleX - paddle.w / 2;

        // Boundaries
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x > canvas.width - paddle.w) paddle.x = canvas.width - paddle.w;
    }

    canvas.addEventListener('mousemove', (e) => handleInput(e.clientX));
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleInput(e.touches[0].clientX);
    }, { passive: false });

    // Restart on Click/Tap
    const triggerReset = () => { if(isGameOver) reset(); };
    canvas.addEventListener('click', triggerReset);
    canvas.addEventListener('touchstart', triggerReset);

    function reset() {
        score = 0; isGameOver = false;
        ball.x = 400; ball.y = 440;
        ball.vx = 5; ball.vy = -5;
        scoreDisplay.innerText = "SCORE: 0";
        initBricks();
        animate();
    }

    function update() {
        if (isGameOver) return;

        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall Bounces
        if (ball.x + ball.r > 800 || ball.x - ball.r < 0) ball.vx = -ball.vx;
        if (ball.y - ball.r < 0) ball.vy = -ball.vy;

        // Paddle Collision
        if (ball.y + ball.r > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w) {
            ball.vy = -5; // Keep speed constant
            // Change angle based on hit location
            let impact = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
            ball.vx = impact * 7; 
        }

        // Brick Collision
        bricks.forEach(b => {
            if (b.active && ball.x > b.x && ball.x < b.x + bW && ball.y > b.y && ball.y < b.y + bH) {
                b.active = false;
                ball.vy = -ball.vy;
                score += 20;
                scoreDisplay.innerText = "SCORE: " + score;
            }
        });

        // Game Over
        if (ball.y > 500) isGameOver = true;
    }

    function draw() {
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, 800, 500);

        // Paddle
        ctx.fillStyle = "#38bdf8";
        ctx.shadowBlur = 10; ctx.shadowColor = "#38bdf8";
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

        // Ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();

        // Bricks
        bricks.forEach(b => {
            if (b.active) {
                ctx.fillStyle = b.color;
                ctx.shadowColor = b.color;
                ctx.fillRect(b.x, b.y, b.W || bW, b.H || bH);
            }
        });
        ctx.shadowBlur = 0;

        if (isGameOver) {
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(0, 0, 800, 500);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.font = "bold 40px Segoe UI";
            ctx.fillText("BALL LOST", 400, 250);
            ctx.font = "20px Segoe UI";
            ctx.fillText("TAP TO RETRY", 400, 300);
        }
    }

    function animate() {
        update();
        draw();
        if (!isGameOver) requestAnimationFrame(animate);
    }

    initBricks();
    animate();
</script>
</body>
</html>
