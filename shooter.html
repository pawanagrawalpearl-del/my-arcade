<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Vanguard - Touch Edition</title>
    <style>
        body { background: #020617; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #38bdf8; font-weight: bold; z-index: 10; }
        canvas { background: #000; border: 2px solid #1e293b; max-width: 95vw; box-shadow: 0 0 30px rgba(56, 189, 248, 0.2); }
        .ui { position: absolute; top: 20px; text-align: center; pointer-events: none; }
        #score { font-size: 2.5rem; font-weight: bold; color: #38bdf8; }
    </style>
</head>
<body>

    <a href="index.html" class="back-link">‚Üê BACK TO ARCADE</a>
    
    <div class="ui">
        <div id="score">0</div>
        <div style="color: #64748b;">Drag to Move & Fire</div>
    </div>

    <canvas id="shooterCanvas" width="600" height="800"></canvas>

<script>
    const canvas = document.getElementById("shooterCanvas");
    const ctx = canvas.getContext("2d");
    const scoreDisplay = document.getElementById("score");

    let score = 0;
    let isGameOver = false;
    let player = { x: 300, y: 700, w: 40, h: 40 };
    let bullets = [];
    let enemies = [];
    let lastShot = 0;

    // --- TOUCH & MOUSE HANDLING ---
    function handleInput(clientX, clientY) {
        if (isGameOver) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        player.x = (clientX - rect.left) * scaleX - player.w / 2;
        player.y = (clientY - rect.top) * scaleY - player.h / 2;

        // Boundaries
        if (player.x < 0) player.x = 0;
        if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
        if (player.y < 0) player.y = 0;
        if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;
    }

    canvas.addEventListener('mousemove', (e) => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleInput(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    canvas.addEventListener('click', () => { if(isGameOver) reset(); });
    canvas.addEventListener('touchstart', (e) => { if(isGameOver) reset(); });

    function spawnEnemy() {
        if (Math.random() < 0.05) {
            enemies.push({ 
                x: Math.random() * (canvas.width - 40), 
                y: -40, 
                w: 40, 
                h: 40, 
                speed: 3 + (score / 1000) 
            });
        }
    }

    function reset() {
        score = 0; bullets = []; enemies = []; isGameOver = false;
        player.x = 300; player.y = 700;
        scoreDisplay.innerText = "0";
        animate();
    }

    function update(time) {
        if (isGameOver) return;

        // Auto-firing
        if (time - lastShot > 150) {
            bullets.push({ x: player.x + player.w/2 - 2, y: player.y, w: 4, h: 15 });
            lastShot = time;
        }

        bullets.forEach((b, bi) => {
            b.y -= 10;
            if (b.y < -20) bullets.splice(bi, 1);
        });

        enemies.forEach((en, ei) => {
            en.y += en.speed;
            
            // Collision with Player
            if (player.x < en.x + en.w && player.x + player.w > en.x &&
                player.y < en.y + en.h && player.y + player.h > en.y) {
                isGameOver = true;
            }

            // Collision with Bullets
            bullets.forEach((b, bi) => {
                if (b.x < en.x + en.w && b.x + b.w > en.x &&
                    b.y < en.y + en.h && b.y + b.h > en.y) {
                    enemies.splice(ei, 1);
                    bullets.splice(bi, 1);
                    score += 10;
                    scoreDisplay.innerText = score;
                }
            });

            if (en.y > canvas.height) enemies.splice(ei, 1);
        });

        spawnEnemy();
    }

    function draw() {
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Player Ship
        ctx.fillStyle = "#38bdf8";
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#38bdf8";
        ctx.fillRect(player.x, player.y, player.w, player.h);

        // Bullets
        ctx.fillStyle = "#fbbf24";
        ctx.shadowColor = "#fbbf24";
        bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

        // Enemies
        ctx.fillStyle = "#f472b6";
        ctx.shadowColor = "#f472b6";
        enemies.forEach(en => ctx.fillRect(en.x, en.y, en.w, en.h));
        
        ctx.shadowBlur = 0;

        if (isGameOver) {
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.font = "bold 40px Rajdhani";
            ctx.fillText("SYSTEM FAILURE", 300, 380);
            ctx.font = "20px Rajdhani";
            ctx.fillText("TAP TO REPAIR & REBOOT", 300, 430);
        }
    }

    function animate(time) {
        update(time);
        draw();
        if (!isGameOver) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
</script>
</body>
</html>
