<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Repulsor Pop - Touch Edition</title>
    <style>
        body { background: #020617; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
        .back-link { position: absolute; top: 20px; left: 20px; text-decoration: none; color: #38bdf8; font-weight: bold; z-index: 10; }
        canvas { background: #000; border: 2px solid #1e293b; max-width: 95vw; max-height: 80vh; cursor: crosshair; }
        .ui { position: absolute; top: 20px; text-align: center; pointer-events: none; }
        #timer { font-size: 2rem; font-weight: bold; color: #38bdf8; }
    </style>
</head>
<body>

    <a href="index.html" class="back-link">‚Üê BACK TO ARCADE</a>
    
    <div class="ui">
        <div id="timer">0.00</div>
        <div style="color: #64748b;">Push the particles away!</div>
    </div>

    <canvas id="gravityCanvas" width="800" height="500"></canvas>

<script>
    const canvas = document.getElementById("gravityCanvas");
    const ctx = canvas.getContext("2d");
    const timerDisplay = document.getElementById("timer");

    let particles = [];
    let startTime = Date.now();
    let mouse = { x: -1000, y: -1000 };

    function init() {
        for (let i = 0; i < 80; i++) {
            particles.push({
                x: Math.random() * 800,
                y: Math.random() * 500,
                r: Math.random() * 4 + 2,
                vx: 0,
                vy: 0,
                color: `hsl(${Math.random() * 60 + 180}, 70%, 60%)`
            });
        }
    }

    // --- UNIVERSAL INPUT HANDLING ---
    function updateMousePos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        // Scale factor for mobile screens
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        mouse.x = (clientX - rect.left) * scaleX;
        mouse.y = (clientY - rect.top) * scaleY;
    }

    canvas.addEventListener('mousemove', (e) => updateMousePos(e.clientX, e.clientY));
    
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Stop scrolling
        updateMousePos(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });

    // Hide mouse/touch when not active
    const hideInput = () => { mouse.x = -1000; mouse.y = -1000; };
    canvas.addEventListener('mouseleave', hideInput);
    canvas.addEventListener('touchend', hideInput);

    function update() {
        let elapsed = (Date.now() - startTime) / 1000;
        timerDisplay.innerText = elapsed.toFixed(2);

        particles.forEach(p => {
            // Friction
            p.vx *= 0.98;
            p.vy *= 0.98;

            // Gravity/Repulsion Logic
            const dx = p.x - mouse.x;
            const dy = p.y - mouse.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 150) {
                const force = (150 - dist) / 1500;
                p.vx += dx * force;
                p.vy += dy * force;
            }

            // Move
            p.x += p.vx;
            p.y += p.vy;

            // Wall Bounce
            if (p.x < 0 || p.x > 800) p.vx *= -1;
            if (p.y < 0 || p.y > 500) p.vy *= -1;
        });
    }

    function draw() {
        ctx.fillStyle = 'rgba(2, 6, 23, 0.2)'; // Tail effect
        ctx.fillRect(0, 0, 800, 500);

        particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
        });

        // Draw Cursor Ring
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, 150, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(56, 189, 248, 0.1)";
        ctx.stroke();

        requestAnimationFrame(() => {
            update();
            draw();
        });
    }

    init();
    draw();
</script>
</body>
</html>
